# 레코드 캡슐화하기
## 배경
### 레코드
- 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있음 -> 훨씬 의미있는 단위로 전달 가능
  - 불변일 경우 사용
  - 구조
    - 필드 이름을 노출하는 형태
    - 필드를 외부로 숨겨서 내가 원하는 이름을 쓸 수 있는 형태
      - 해시, 맵, 해시맵, 딕셔너리, 연관배열 등등..
  - 단점 : 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야하는 점이 번거로움(?)
    - 시작과 끝과 길이를 알아야..
### 객체
- 가변 데이터의 경우, 레코드보다는 객체
  - 저장된 값/계산된 값의 구분이 필요 없음
  - 필드 이름을 바꿔도 기존 이름과 새 이름 모두를 각각의 메소드로 제공할 수 있다 -> 점진적 변경 가능
- 중첩된 리스트나 해시맵을 받아서 JSON이나 XML 같은 포맷으로 직렬화하는 경우

## 절차
1. 레코드를 담은 변수를 캡슐화
2. 레코드를 감싼 단순한 클래스로 해당 변수 내용 교체
   - 클래스에 원본 레코드를 반환하는 접근자 정의
   - 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정
3. 테스트
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체 반환 함수 만들기
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4.에서 만든 새 함수를 사용하도록 변경
  - 필드에 접근할 땐 접근자 사용
    - 없으면 추가
  - 한 부분을 바꿀때마다 테스트
  - 클라이언트가 단순히 데이터를 읽는 경우 -> 데이터의 복제본/프록시 반환 고려
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수 제거
7. 테스트
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용
9. 