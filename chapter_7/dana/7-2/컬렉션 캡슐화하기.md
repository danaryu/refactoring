# 컬렉션 캡슐화하기
## 배경
- 컬렉션의 원소들이 바뀌어버릴 수 있는 상황들을 주의하자
  - 컬렉션을 감싼 클래스에 `add()` `remove()`와 같은 컬렉션 변경자 메소드를 만들자
    - 컬렉션을 소유한 클래스를 통해서만 원소 변경
- 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 컬렉션이 바뀔 가능성조차 없애기
  - 방법 1. 컬렉션 값을 반환하지 못하도록
    - 컬렉션이 소속된 클래스의 적절한 메소드를 반드시 거치도록
      - `aCustomer.orders.size()` → `aCustomer.numberOfOrders()`
      - 부가적인 코드가 늘어나고, 컬렉션 연산들을 조합하기 어려움
    - 위 방법 보다는 표준화된 인터페이스로 제공되는 컬렉션을 사용하자
  - 방법 2. 컬렉션을 읽기 전용으로 제공
    - Proxy 사용
      - 내부 컬렉션을 읽는 연산은 그대로
      - 쓰기는 철벽방어
    - 원본 데이터를 수정하는 과정이 겉으로 드러남
  - 방법 3. 컬렉션 게터는 제공 But 복제본을 반환 *(가장 흔히 사용)*
    - 복제본을 수정해도 원본 컬렉션에는 영향 없음
    - 컬렉션이 상당히 크다면 성능 문제가 있을수도.... But 그런경우는 별로 없어서..
> 방법 1~3 중에 한가지만 적용해서 컬렉션 접근 함수의 동작 방식 통일 **(코드 베이스 일관성 유지)**

## 절차
1. 컬렉션을 캡슐화 하기 전에 변수 캡슐화 먼저
2. 컬렉션에 원소를 추가/제거하는 함수 추가 (add, remove)
  - setter를 없애라 못없애면 복사로ㄱ
3. 정적 검사 수행
4. 컬렉션을 참조하는 부분을 모두 찾고, 컬렉션의 변경자를 호출하는 코드가 추가/제거 함수를 통해 수행하도록 변경
5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 Proxy나 복제본 반환
6. 테스트

