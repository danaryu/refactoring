# 챕터 내용 정리

> 리팩터링은 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.

> 종료 기준보다는 리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.

## 3장 - 코드에서 나는 악취

### 3.1 기이한 이름 (Mysterious Name)

- 코드의 명료함에는 '이름'이 매우 중요함
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높음

### 3.2 중복 코드 (Duplicated Code)

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있음
- 해결 방법
    - 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → 함수 추출하기(6.1)
    - 코드가 비슷하지만 완전히 똑같지는 않은 경우 → 문장 슬라이드하기(8.6) → 함수 추출하기
    - 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있는 경우 → 메서드 올리기(12.1)
    
### 3.3 긴 함수 (Long Function)

- 경험상 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성되어있음
- 장점 : 간접 호출(indirection)의 효과
    - 이해하고, 공유하고, 선택하기 쉬워짐
- 단점 
    - 코드를 읽을 때 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 함
        - 함수 호출부와 선언부 확인을 도와주는 개발환경으로 보완
        - 함수 이름이 잘 지어져 있으면 본문 코드를 볼 필요가 없음. 이를 위해서는 **훨씬 적극적으로 함수를 쪼개야** 함

#### 함수 쪼개기

- 주석을 달아야 할 부분은 무조건 함수로 만듦
    - 본문 : 원래 주석으로 설명하려던 코드
    - 이름 : 동작 방식이 아닌 '의도(intention)'가 드러남
    - 함수의 의도와 구현 코드의 괴리가 클수록 함수로 만드는게 유리
        > '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다
- 해결 방법
    - 99% → 함수 추출하기(6.1)
    - 함수가 임시 변수, 매개 변수를 많이 사용할 경우 
        - 임시 변수 → 임시 변수를 질의 함수로 바꾸기(7.4)
        - 매개 변수 → 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4)
        - 그래도 많을 경우 → 함수를 명령으로 바꾸기(11.4)
    - 조건문 → 조건문 분해하기(10.1), case문마다 함수 추출하기(6.1)
    - 같은 조건을 기준으로 나뉘는 switch 문이 여러 개일 경우 → 조건문을 다형성으로 바꾸기(10.4)
    - 추출한 반복문 코드에 적합한 이름이 떠오르지 않을 경우 → 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있음 → 반복문 쪼개기(8.7)
    
### 3.4 긴 매개변수 목록 (Long Parameter List)

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려워짐
- 해결 방법
    - 다른 매개변수에서 값을 얻어올 수 있는 경우 → 매개변수를 질의 함수로 바꾸기(11.5)
    - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달할 경우 → 객체 통째로 넘기기(11.4)
    - 항상 함께 전달되는 매개변수일 경우 → 매개변수 객체 만들기(6.8)
    - 함수의 동작 방식을 정하는 플래그 역할의 매개변수일 경우 → 플래그 인수 제거하기(11.3)
    - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 경우 → 여러 함수를 클래스로 묶기(6.9) (함수형 프로그래밍일 경우 부분 적용 함수(partially applied function)을 생성함)

### 3.5 전역 데이터 (Global Data)

- 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없음
- 해결 방법
    - 변수 캡슐화하기(6.6)
    - 접근자 함수들의 접근 범위를 최소화하기
    
### 3.6 가변 데이터 (Mutable Data)

- 데이터를 수정했으나, 코드의 다른 곳에서는 다른 값을 기대하는 경우 버그 발생
- 해결 방법
    - 함수형 프로그래밍 (데이터는 변경되지 않는다는 원칙)
    - 변수 캡슐화하기(6.6) : 값이 어떻게 수정되는지 감시하고, 개선하기 쉬움
    - 파생 변수를 질의 함수로 바꾸기(9.3)
    - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우 → 변수 쪼개기(9.1)
    - 갱신 로직의 경우 부작용이 없는 코드와 분리하는게 좋음 → 문장 슬라이드하기(8.6), 함수 추출하기(6.1)
    - API를 만들 때 → 질의 함수와 변경 함수 분리하기(11.1)
    - 가능한 경우 → 세터 제거하기(11.7)
    - 변수의 유효 범위가 넓어질 경우 → 여러 함수를 클래스로 묶기(6.9), 여러 함수를 변환 함수로 묶기(6.10) : 변수를 갱신하는 코드들의 유효범위를 제한
    - 구조체처럼 내부 필드에 데이터를 담고 있는 변수의 경우 → 참조를 값으로 바꾸기(9.4)
    
### 3.7 뒤엉킨 변경 (Divergent Change)

- 코드를 수정할 때 여러 곳을 동시에 건드려야 할 경우 악취가 풍김 : (1) 뒤엉킨 변경, (2) 산탄총 수술    
- 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타남
- 해결 방법
    - 순차적으로 실행되는 일의 경우 → 단계 쪼개기(6.11)
    - 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우 → 함수 옮기기(8.1) : 처리 과정이 맥락별로 구분됨
        - 여러 맥락의 일에 관여하는 함수가 있을 경우 → 함수 추출하기(6.1)
        - 모듈이 클래스일 경우 → 클래스 추출하기(7.5)
   
### 3.8 산탄총 수술 (Shotgun Surgery)

- 뒤엉킨 변경과 비슷하면서도 정반대의 경우
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생
    - 수정할 부분을 찾기도 어렵고, 꼭 수정해야 할 곳을 지나치기 쉬움
- 해결 방법
    - 함수 옮기기(8.1), 필드 옮기기(8.2) : 모두 한 모듈에 묶어두기
    - 비슷한 데이터를 다루는 함수가 많을 경우 → 여러 함수를 클래스로 묶기(6.9)
    - 데이터 구조를 변환하거나 보강(enrich)하는 함수들의 경우 → 여러 함수를 변환 함수로 묶기(6.10)
        - 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있는 경우 → 단계 쪼개기(6.11)
    - 함수 인라인하기(6.2), 클래스 인라인하기(7.6)
        - 메서드나 클래스가 비대해 지지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐져도 괜찮음

### 3.9 기능 편애 (Feature Envy)

- 모듈화 할 때 코드를 여러 영역으로 나누고 응집력을 높이고 커플링을 낮춰야 함
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 것과 더 많이 상호작용 할 때 발생
- 해결 방법
    - 함수 옮기기(8.1) : 데이터 근처로 이동
    - 함수의 일부에서만 기능 편애가 발생하는 경우 → 함수 추출하기(6.1), 함수 옮기기(8.1)
    - 어디로 옮길 지 명확하지 않을 경우 → 함수 추출하기(6.1) : 함수를 여러 조각으로 나눠 각각을 적합한 모듈로 이동
    - 전략 패턴(Strategy Pattern), 방문자 패턴(Visitor Pattern)

#### 뒤엉킨 변경 vs 산탄총 수술

|         | 뒤엉킨 변경  | 산탄총 수술 |
| :-------: |:----------:| :---------: |
| 원인      | 맥락을 잘 구분하지 못함 |
| 해법      | 맥락을 명확히 구분 |
| 발생 원인 | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐 |
| 해결책    | 맥락별로 분리 | 맥락별로 모음|

# todo - 챕터 내용 정리

> 리팩터링은 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.

> 종료 기준보다는 리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.

## 3장 - 코드에서 나는 악취

### 3.1 기이한 이름 (Mysterious Name)

- 코드의 명료함에는 '이름'이 매우 중요함
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높음

### 3.2 중복 코드 (Duplicated Code)

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있음
- 해결 방법
    - 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → 함수 추출하기(6.1)
    - 코드가 비슷하지만 완전히 똑같지는 않은 경우 → 문장 슬라이드하기(8.6) → 함수 추출하기
    - 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있는 경우 → 메서드 올리기(12.1)
    
### 3.3 긴 함수 (Long Function)

- 경험상 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성되어있음
- 장점 : 간접 호출(indirection)의 효과
    - 이해하고, 공유하고, 선택하기 쉬워짐
- 단점 
    - 코드를 읽을 때 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 함
        - 함수 호출부와 선언부 확인을 도와주는 개발환경으로 보완
        - 함수 이름이 잘 지어져 있으면 본문 코드를 볼 필요가 없음. 이를 위해서는 **훨씬 적극적으로 함수를 쪼개야** 함

#### 함수 쪼개기

- 주석을 달아야 할 부분은 무조건 함수로 만듦
    - 본문 : 원래 주석으로 설명하려던 코드
    - 이름 : 동작 방식이 아닌 '의도(intention)'가 드러남
    - 함수의 의도와 구현 코드의 괴리가 클수록 함수로 만드는게 유리
        > '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다
- 해결 방법
    - 99% → 함수 추출하기(6.1)
    - 함수가 임시 변수, 매개 변수를 많이 사용할 경우 
        - 임시 변수 → 임시 변수를 질의 함수로 바꾸기(7.4)
        - 매개 변수 → 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4)
        - 그래도 많을 경우 → 함수를 명령으로 바꾸기(11.4)
    - 조건문 → 조건문 분해하기(10.1), case문마다 함수 추출하기(6.1)
    - 같은 조건을 기준으로 나뉘는 switch 문이 여러 개일 경우 → 조건문을 다형성으로 바꾸기(10.4)
    - 추출한 반복문 코드에 적합한 이름이 떠오르지 않을 경우 → 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있음 → 반복문 쪼개기(8.7)
    
### 3.4 긴 매개변수 목록 (Long Parameter List)

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려워짐
- 해결 방법
    - 다른 매개변수에서 값을 얻어올 수 있는 경우 → 매개변수를 질의 함수로 바꾸기(11.5)
    - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달할 경우 → 객체 통째로 넘기기(11.4)
    - 항상 함께 전달되는 매개변수일 경우 → 매개변수 객체 만들기(6.8)
    - 함수의 동작 방식을 정하는 플래그 역할의 매개변수일 경우 → 플래그 인수 제거하기(11.3)
    - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 경우 → 여러 함수를 클래스로 묶기(6.9) (함수형 프로그래밍일 경우 부분 적용 함수(partially applied function)을 생성함)

### 3.5 전역 데이터 (Global Data)

- 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없음
- 해결 방법
    - 변수 캡슐화하기(6.6)
    - 접근자 함수들의 접근 범위를 최소화하기
    
### 3.6 가변 데이터 (Mutable Data)

- 데이터를 수정했으나, 코드의 다른 곳에서는 다른 값을 기대하는 경우 버그 발생
- 해결 방법
    - 함수형 프로그래밍 (데이터는 변경되지 않는다는 원칙)
    - 변수 캡슐화하기(6.6) : 값이 어떻게 수정되는지 감시하고, 개선하기 쉬움
    - 파생 변수를 질의 함수로 바꾸기(9.3)
    - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우 → 변수 쪼개기(9.1)
    - 갱신 로직의 경우 부작용이 없는 코드와 분리하는게 좋음 → 문장 슬라이드하기(8.6), 함수 추출하기(6.1)
    - API를 만들 때 → 질의 함수와 변경 함수 분리하기(11.1)
    - 가능한 경우 → 세터 제거하기(11.7)
    - 변수의 유효 범위가 넓어질 경우 → 여러 함수를 클래스로 묶기(6.9), 여러 함수를 변환 함수로 묶기(6.10) : 변수를 갱신하는 코드들의 유효범위를 제한
    - 구조체처럼 내부 필드에 데이터를 담고 있는 변수의 경우 → 참조를 값으로 바꾸기(9.4)
    
### 3.7 뒤엉킨 변경 (Divergent Change)

- 코드를 수정할 때 여러 곳을 동시에 건드려야 할 경우 악취가 풍김 : (1) 뒤엉킨 변경, (2) 산탄총 수술    
- 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타남
- 해결 방법
    - 순차적으로 실행되는 일의 경우 → 단계 쪼개기(6.11)
    - 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우 → 함수 옮기기(8.1) : 처리 과정이 맥락별로 구분됨
        - 여러 맥락의 일에 관여하는 함수가 있을 경우 → 함수 추출하기(6.1)
        - 모듈이 클래스일 경우 → 클래스 추출하기(7.5)
   
### 3.8 산탄총 수술 (Shotgun Surgery)

- 뒤엉킨 변경과 비슷하면서도 정반대의 경우
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생
    - 수정할 부분을 찾기도 어렵고, 꼭 수정해야 할 곳을 지나치기 쉬움
- 해결 방법
    - 함수 옮기기(8.1), 필드 옮기기(8.2) : 모두 한 모듈에 묶어두기
    - 비슷한 데이터를 다루는 함수가 많을 경우 → 여러 함수를 클래스로 묶기(6.9)
    - 데이터 구조를 변환하거나 보강(enrich)하는 함수들의 경우 → 여러 함수를 변환 함수로 묶기(6.10)
        - 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있는 경우 → 단계 쪼개기(6.11)
    - 함수 인라인하기(6.2), 클래스 인라인하기(7.6)
        - 메서드나 클래스가 비대해 지지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐져도 괜찮음

### 3.9 기능 편애 (Feature Envy)

- 모듈화 할 때 코드를 여러 영역으로 나누고 응집력을 높이고 커플링을 낮춰야 함
- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 것과 더 많이 상호작용 할 때 발생
- 해결 방법
    - 함수 옮기기(8.1) : 데이터 근처로 이동
    - 함수의 일부에서만 기능 편애가 발생하는 경우 → 함수 추출하기(6.1), 함수 옮기기(8.1)
    - 어디로 옮길 지 명확하지 않을 경우 → 함수 추출하기(6.1) : 함수를 여러 조각으로 나눠 각각을 적합한 모듈로 이동
    - 전략 패턴(Strategy Pattern), 방문자 패턴(Visitor Pattern)

#### 뒤엉킨 변경 vs 산탄총 수술

|         | 뒤엉킨 변경  | 산탄총 수술 |
| :-------: |:----------:| :---------: |
| 원인      | 맥락을 잘 구분하지 못함 |
| 해법      | 맥락을 명확히 구분 |
| 발생 원인 | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐 |
| 해결책    | 맥락별로 분리 | 맥락별로 모음|

### 3.10 데이터 뭉치 (Data Clumps)

- 데이터 여러개가 여러 곳에서 항상 함께 뭉쳐 다닐 경우 발생
- 데이터 뭉치인지 헷갈린다면?
    - 값 하나를 삭제해 보았을 때 나머지 데이터만으로는 의미가 없을 경우!
- 해결 방법
    - 필드 형태의 데이터 뭉치일 경우 → 클래스 추출하기(7.5) : 추후 클래스로 다른 기능을 옮겨서 추가로 생산성에 기여할 수 있음
    - 메서드 시그니처에 있을 경우 → 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4)

### 3.11 기본형 집착 (Primitive Obsession)

- 주어진 문제에 딱 맞는 기초 타입을 정의하지 않고, 프로그래밍 언어에서 주어진 기본형만을 사용할 경우 발생
- 예시
    - 금액을 그냥 숫자형으로 계산
    - 물리량임에도 밀리미터, 인치 등 단위를 무시함
    - 전화번호를 단순히 문자 집합으로만 표현함 : 문자열화된 변수(stringly typed)
- 해결 방법
    - 기본형을 객체로 바꾸기(7.3)
    - 조건부 동작을 제어하는 타입 코드(type code)로 쓰였을 경우 → 타입 코드를 서브클래스로 바꾸기(12.6), 조건부 로직을 다형성으로 바꾸기(10.4)
    - 자주 함께 몰려다니는 기본형 그룹 : 데이터 뭉치

### 3.12 반복되는 switch문 (Repeated Switches)

- 똑같은 조건부 로직이 여러 곳에서 반복해 등장할 경우 발생
- 해결 방법
    - 조건부 로직을 다형성으로 바꾸기(10.4)
    
### 3.13 반복문 (Loops)

- 해결 방법
    - 일급 함수(first-class function) : 반복문을 파이프라인으로 바꾸기(8.8)

### 3.14 성의 없는 요소 (Lazy Element)

- 내용을 그대로 쓰는 것과 다를 바 없는 함수, 메서드가 하나뿐인 클래스 등
- 해결 방법
    - 함수 인라인하기(6.2), 클래스 인라인하기(7.6)
    - 상속을 사용했을 경우 → 계층 합치기(12.9)

### 3.15 추측성 일반화 (Speculative Generality)

- '나중에 필요할 거야' 같은 생각으로 당장 필요 없는 모든 종류의 후킹(hooking) 포인트와 특이 케이스 처리 로직을 작성했을 경우
- 이해 / 관리가 어려워짐
- 해결 방법
    - 추상 클래스 → 계층 합치기(12.9)
    - 쓸데 없이 위임하는 코드 → 함수 인라인하기(6.2), 클래스 인라인하기(7.6)
    - 본문에서 사용되지 않는 매개변수 → 함수 선언 바꾸기(6.5)
    - 테스트 코드 외에 사용하지 않는 코드 → 죽은 코드 제거하기(8.9)

### 3.16 임시 필드 (Temporary Field)

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스의 경우
- 객체를 이용할 때는 당연히 모든 필드가 채워져 있을 거라 생각하기 쉬우므로 코드의 이해를 해침
- 해결 방법
    - 클래스 추출하기(7.5)
    - 함수 옮기기(8.1)
    - 임시 필드들의 유효성 체크 후 동작하는 조건부 로직의 경우 → 특이 케이스 추가하기(10.5) : 유효하지 않을 경우를 위한 대안 클래스 생성

### 3.17 메시지 체인 (Message Chains)

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 또 다른 객체를 요청하는 식으로 요청하는 작업이 연쇄적으로 이어지는 경우 발생
- 클라이언트가 객체 내비게이션 구조에 종속됨
- 예시
    - 게터가 꼬리에 꼬리를 물고 이어짐
    - 임시 변수들이 줄줄이 나열됨
- 해결 방법
    - 위임 숨기기(7.7)
        - 중간 객체들이 중개자(3.18)가 되어버리기 쉬움 → 함수 추출하기(6.1), 함수 옮기기(8.1)
        
### 3.18 중개자 (Middle Man)

- 캡슐화를 진행하며 위임(delegation)이 지나치게 사용되는 경우 발생
- 해결 방법
    - 중개자 제거하기(7.8)
        - 위임 메서드를 제거한 후 남는 일이 너무 없을 경우 → 함수 인라인하기(6.2)

### 3.19 내부자 거래 (Insider Trading)

- 해결 방법
    - 함수 옮기기(8.1)
    - 필드 옮기기(8.2)
    - 여러 모듈들이 같은 관심사를 공유할 경우 → 위임 숨기기(7.7) : 다른 모듈이 중간자 역할을 하게 함
    - 상속 구조일 경우 → 써브클래스를 위임으로 바꾸기(12.10), 슈퍼클래스를 위임으로 바꾸기(12.11)
    
### 3.20 거대한 클래스 (Large Class)

- 해결 방법
    - 클래스 추출하기(7.5)
    - 상속관계로 만드는게 좋을 경우 → 슈퍼클래스 추출하기(12.8), 타입 코드를 서브클래스로 바꾸기(12.6)
    - 클라이언트들의 클래스 사용 패턴 분석 → 클래스 추출하기(7.5), 슈퍼클래스 추출하기(12.8), 타입 코드를 서브클래스로 바꾸기(12.6)
    
### 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

- 클래스들의 인터페이스가 같다면 언제든 다른 클래스로 교체하기가 용이해짐
- 해결 방법
    - 함수 선언 바꾸기(6.5) : 메서드 시그니처 일치화
    - 함수 옮기기(8.1) : 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 넣음
    - 중복 코드가 발생할 경우 → 슈퍼클래스 추출하기(12.8)

### 3.22 데이터 클래스 (Data Class)

- 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 다른 클래스가 너무 깊이까지 함부로 다룰 경우 문제
- 해결 방법
    - 레코드 캡슐화하기(7.1)
    - 세터 제거하기(11.7)
    - 다른 클래스에서 게터나 세터를 사용하는 메서드가 있을 경우 → 함수 옮기기(8.1), 함수 추출하기(6.1)
- 예외
    - 단계 쪼개기(6.11) 결과로 나온 중간 데이터 구조일 경우 불변(immutable)이므로 필드를 그냥 공개해두어도 괜찮음
    
### 3.23 상속 포기 (Refused Bequest)

계층 구조를 잘못 설계했을 경우 발생
- 해결 방법
    - 같은 계층에 서브클래스를 만들고, 메서드 내리기(12.4), 필드 내리기(12.5)
    - 서브클래스가 부모의 인터페이스를 따르지 않을 경우 → 서브클래스를 위임으로 바꾸기(12.10), 슈퍼클래스를 위임으로 바꾸기(12.11) : 상속을 벗어남 
- 예외
    - 가끔은 동작을 재활용 하는 목적으로 상속을 활용해도 괜찮음

### 3.24 주석 (Comments)

- 주석이 장황하게 달렸다면, 코드를 잘못 작성했기 때문일 수도 있음
- 해결 방법
    - 특정 코드 블록에 주석을 남기고 싶을 경우 → 함수 추출하기(6.1)
    - 이미 추출된 함수지만 여전히 주석이 필요할 경우 → 함수 선언 바꾸기(6.5)
    - 시스템이 동작하기 위한 선행조건을 명시하고 싶은 경우 → 어서션 추가하기(10.6)
> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
- 예외
    - 뭘 할지 모를 때, 확실하지 않은 부분에 남김
    - 코드를 지금처럼 작성한 이유를 설명하는 용도로 남김
    
  
 